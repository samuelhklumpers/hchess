{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeApplications #-}
module Test where

import Data.Constraint.Extras.TH (deriveArgDict)
import Data.Dependent.Map (DMap, fromList, singleton, union, unionWithKey, lookup, insert)
import qualified Data.Dependent.Map as DM
import Data.Dependent.Sum ((==>))
import Data.Functor.Identity (Identity(..))
import Data.GADT.Compare.TH (deriveGCompare, deriveGEq)
import Type.Reflection
import Data.GADT.Show.TH (deriveGShow)
-- Data.Dependent.Map.Lens

data Tag a where
  DynKey    :: TypeRep a -> String -> Tag a
deriveGEq ''Tag
deriveGCompare ''Tag
deriveGShow ''Tag
--deriveArgDict ''Tag -- Tag is not finite

x :: DMap Tag Identity
x = fromList [DynKey (typeRep @String) "theKey" ==> "abcd"]

y :: DMap Tag Identity
y = DM.insert (DynKey (typeRep @String) "theOtherKey") (Identity "acdefgh") x
